## Улучшенная тестируемость
Представим, что у нас есть приложение для заказа еды, и мы тестируем функциональность поиска ресторанов. В OOP, если RestaurantSearchManager наследуется от какого-то базового класса с реализацией поиска, может быть сложно протестировать только его логику, не затрагивая всю цепочку наследования.

В POP мы можем создать протокол RestaurantSearchable:
```
protocol RestaurantSearchable {
    func searchRestaurants(by name: String, completion: @escaping ([Restaurant]) -> Void)
}

class RestaurantSearchManager: RestaurantSearchable {
    func searchRestaurants(by name: String, completion: @escaping ([Restaurant]) -> Void) {
        // Реальная логика поиска ресторанов
    }
}
```

Теперь в тестах мы можем легко создать мок-объект, который будет соответствовать RestaurantSearchable:
```
class MockRestaurantSearchManager: RestaurantSearchable {
    func searchRestaurants(by name: String, completion: @escaping ([Restaurant]) -> Void) {
        // Возвращаем фиксированные данные для тестирования
        completion([Restaurant(name: "Testaurant")])
    }
}
```

Это позволяет протестировать логику, не зависящую от реальной реализации поиска ресторанов.

## Слабая связанность и модульность
Допустим, у нас есть приложение для управления задачами, и мы хотим реализовать функцию уведомлений. В OOP часто создается подкласс, который наследует логику от основного класса задачи и добавляет логику для уведомлений, что создает тесную связанность.

В POP мы можем создать протокол Notifiable, который определяет поведение для отправки уведомлений:
```
protocol Notifiable {
    func sendNotification()
}

struct Task: Notifiable {
    var title: String
    
    func sendNotification() {
        print("Уведомление: Задача \(title) должна быть выполнена")
    }
}
```

Теперь любое задание, которое нужно уведомить, может соответствовать протоколу Notifiable, что позволяет легко добавлять уведомления для любых типов задач без необходимости создавать сложные иерархии классов.

## Производительность и безопасность
Рассмотрим пример приложения для обработки больших объемов данных, где важно сохранить производительность. В OOP наследование может привести к избыточным вычислениям, если классы перегружены ненужными методами.

В POP можно использовать протоколы с типами значений для достижения высокой производительности. Например:
```
protocol DataProcessor {
    func process(data: [Int]) -> Int
}

struct FastDataProcessor: DataProcessor {
    func process(data: [Int]) -> Int {
        return data.reduce(0, +)
    }
}
```
Используя структуры, которые не наследуют от других классов и работают с протоколами, мы получаем эффективную и безопасную реализацию. Структуры в Swift работают напрямую с памятью, что делает их более быстрыми и безопасными, так как они не имеют проблем с утечкой памяти, характерных для классов.
